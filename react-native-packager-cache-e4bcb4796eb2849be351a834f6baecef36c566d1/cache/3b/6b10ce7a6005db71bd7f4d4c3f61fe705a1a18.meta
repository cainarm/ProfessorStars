["df006fbaab3d9a7011c3b351d5b110974aff7363","77a8736d9e18644206408f974e3dd6825bcc74be",["react","prop-types","hoist-non-react-statics","lodash","./StyleNormalizer/normalizeStyle","react-native","./Theme","./resolveComponentStyle"],[87,182,301,441,538,680,719,828],{"version":3,"sources":["/home/cainarm/professorStars/node_modules/native-base-shoutem-theme/src/connectStyle.js"],"names":["_","themeCache","throwConnectStyleError","errorMessage","componentDisplayName","Error","getTheme","context","theme","getDefaultTheme","isStyleVariant","propertyName","test","isChildStyle","getConcreteStyle","style","pickBy","value","key","componentStyleName","componentStyle","mapPropsToStyleNames","options","getComponentDisplayName","WrappedComponent","displayName","name","wrapWithStyledComponent","isPlainObject","isString","StyledComponent","props","styleNames","getStyleNames","finalStyle","getFinalStyle","setWrappedInstance","bind","resolveConnectedComponentStyle","state","addedProps","resolveAddedProps","resolvedStyle","parentPath","getOrSetStylesInCache","resolveStyle","concreteStyle","merge","isArray","styleNamesArr","map","remove","index","getParentPath","nextProps","nextContext","shouldRebuildStyle","setState","nativeProps","wrappedInstance","setNativeProps","component","_root","isEqual","styleName","hasStyleNameChanged","split","uniq","withRef","ref","path","join","Object","keys","length","parentStyle","themeStyle","createComponentStyle","resolveStyleNames","Component","contextTypes","array","childContextTypes","propTypes","oneOfType","object","number","string","virtual","bool","defaultProps"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\nimport normalizeStyle from './StyleNormalizer/normalizeStyle';\nimport { StyleSheet } from \"react-native\";\n\nimport Theme, { ThemeShape } from \"./Theme\";\nimport { resolveComponentStyle } from \"./resolveComponentStyle\";\n\nconst themeCache = {};\n\n/**\n * Formats and throws an error when connecting component style with the theme.\n *\n * @param errorMessage The error message.\n * @param componentDisplayName The name of the component that is being connected.\n */\nfunction throwConnectStyleError(errorMessage, componentDisplayName) {\n  throw Error(\n    `${errorMessage} - when connecting ${componentDisplayName} component to style.`\n  );\n}\n\n/**\n * Returns the theme object from the provided context,\n * or an empty theme if the context doesn't contain a theme.\n *\n * @param context The React component context.\n * @returns {Theme} The Theme object.\n */\nfunction getTheme(context) {\n  // Fallback to a default theme if the component isn't\n  // rendered in a StyleProvider.\n  return context.theme || Theme.getDefaultTheme();\n}\n\n/**\n * Matches any style properties that represent component style variants.\n * Those styles can be applied to the component by using the styleName\n * prop. All style variant property names must start with a single '.'\n * character, e.g., '.variant'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\n */\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\n/**\n * Matches any style properties that represent style rules that target the\n * component children. Those styles can have two formats, they can either\n * target the components by component name ('shoutem.ui.Text'), or by component\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\n * component name, those styles can also target any component by using the\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\n * that they have to contain a '.' character in their name or be a '*'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a child style, false otherwise.\n */\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\nfunction getConcreteStyle(style) {\n  return _.pickBy(style, (value, key) => {\n    return !isStyleVariant(key) && !isChildStyle(key);\n  });\n}\n\n/**\n * Resolves the final component style by using the theme style, if available and\n * merging it with the style provided directly through the style prop, and style\n * variants applied through the styleName prop.\n *\n * @param componentStyleName The component name that will be used\n * to target this component in style rules.\n * @param componentStyle The default component style.\n * @param mapPropsToStyleNames Pure function to customize styleNames depending on props.\n * @param options The additional connectStyle options\n * @param options.virtual The default value of the virtual prop\n * @param options.withRef Create component ref with addedProps; if true, ref name is wrappedInstance\n * @returns {StyledComponent} The new component that will handle\n * the styling of the wrapped component.\n */\nexport default (\n  componentStyleName,\n  componentStyle = {},\n  mapPropsToStyleNames,\n  options = {}\n) => {\n  function getComponentDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n  }\n\n  return function wrapWithStyledComponent(WrappedComponent) {\n    const componentDisplayName = getComponentDisplayName(WrappedComponent);\n\n    if (!_.isPlainObject(componentStyle)) {\n      throwConnectStyleError(\n        \"Component style must be plain object\",\n        componentDisplayName\n      );\n    }\n\n    if (!_.isString(componentStyleName)) {\n      throwConnectStyleError(\n        \"Component Style Name must be string\",\n        componentDisplayName\n      );\n    }\n\n    class StyledComponent extends React.Component {\n      static contextTypes = {\n        theme: ThemeShape,\n        // The style inherited from the parent\n        // parentStyle: PropTypes.object,\n        parentPath: PropTypes.array\n      };\n\n      static childContextTypes = {\n        // Provide the parent style to child components\n        // parentStyle: PropTypes.object,\n        // resolveStyle: PropTypes.func,\n        parentPath: PropTypes.array\n      };\n\n      static propTypes = {\n        // Element style that overrides any other style of the component\n        style: PropTypes.oneOfType([\n          PropTypes.object,\n          PropTypes.number,\n          PropTypes.array\n        ]),\n        // The style variant names to apply to this component,\n        // multiple variants may be separated with a space character\n        styleName: PropTypes.string,\n        // Virtual elements will propagate the parent\n        // style to their children, i.e., the children\n        // will behave as they are placed directly below\n        // the parent of a virtual element.\n        virtual: PropTypes.bool\n      };\n\n      static defaultProps = {\n        virtual: options.virtual\n      };\n\n      static displayName = `Styled(${componentDisplayName})`;\n      static WrappedComponent = WrappedComponent;\n\n      constructor(props, context) {\n        super(props, context);\n        // console.log(context.parentPath);\n        const styleNames = this.getStyleNames(props);\n        const style = props.style;\n\n        const finalStyle = this.getFinalStyle(\n          props,\n          context,\n          style,\n          styleNames\n        );\n\n        this.setWrappedInstance = this.setWrappedInstance.bind(this);\n        this.resolveConnectedComponentStyle = this.resolveConnectedComponentStyle.bind(\n          this\n        );\n        this.state = {\n          style: finalStyle,\n          // AddedProps are additional WrappedComponent props\n          // Usually they are set trough alternative ways,\n          // such as theme style, or trough options\n          addedProps: this.resolveAddedProps(),\n          styleNames\n        };\n      }\n\n      getFinalStyle(props, context, style, styleNames) {\n        let resolvedStyle = {};\n        if (context.parentPath) {\n          resolvedStyle = this.getOrSetStylesInCache(\n            context,\n            props,\n            styleNames,\n            [...context.parentPath, componentStyleName, ...styleNames]\n          );\n        } else {\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\n          themeCache[componentStyleName] = resolvedStyle;\n        }\n\n        const concreteStyle = getConcreteStyle(_.merge({}, resolvedStyle));\n\n        if (_.isArray(style)) {\n          return [concreteStyle, ...style];\n        }\n\n        if (typeof style == \"number\" || typeof style == \"object\") {\n          return [concreteStyle, style];\n        }\n\n        return concreteStyle;\n      }\n\n      getStyleNames(props) {\n        const styleNamesArr = _.map(props, (value, key) => {\n          if (typeof value !== \"object\" && value === true) {\n            return \".\" + key;\n          } else {\n            return false;\n          }\n        });\n        _.remove(styleNamesArr, (value, index) => {\n          return value === false;\n        });\n\n        return styleNamesArr;\n      }\n\n      getParentPath() {\n        if (!this.context.parentPath) {\n          return [componentStyleName];\n        } else {\n          return [\n            ...this.context.parentPath,\n            componentStyleName,\n            ...this.getStyleNames(this.props)\n          ];\n        }\n      }\n\n      getChildContext() {\n        return {\n          // parentStyle: this.props.virtual ?\n          //   this.context.parentStyle :\n          //   this.state.childrenStyle,\n          // resolveStyle: this.resolveConnectedComponentStyle,\n          parentPath: this.getParentPath()\n        };\n      }\n\n      componentWillReceiveProps(nextProps, nextContext) {\n        const styleNames = this.getStyleNames(nextProps);\n        const style = nextProps.style;\n        if (this.shouldRebuildStyle(nextProps, nextContext, styleNames)) {\n          const finalStyle = this.getFinalStyle(\n            nextProps,\n            nextContext,\n            style,\n            styleNames\n          );\n\n          this.setState({\n            style: finalStyle,\n            // childrenStyle: resolvedStyle.childrenStyle,\n            styleNames\n          });\n        }\n      }\n\n      setNativeProps(nativeProps) {\n        if (this.wrappedInstance.setNativeProps) {\n          this.wrappedInstance.setNativeProps(nativeProps);\n        }\n      }\n\n      setWrappedInstance(component) {\n        if (component && component._root) {\n          this._root = component._root;\n        } else {\n          this._root = component;\n        }\n        this.wrappedInstance = this._root;\n      }\n\n      hasStyleNameChanged(nextProps, styleNames) {\n        return (\n          mapPropsToStyleNames &&\n          this.props !== nextProps &&\n          // Even though props did change here,\n          // it doesn't necessary means changed props are those which affect styleName\n          !_.isEqual(this.state.styleNames, styleNames)\n        );\n      }\n\n      shouldRebuildStyle(nextProps, nextContext, styleNames) {\n        return (\n          nextProps.style !== this.props.style ||\n          nextProps.styleName !== this.props.styleName ||\n          nextContext.theme !== this.context.theme ||\n          !_.isEqual(nextContext.parentPath, this.context.parentPath) ||\n          this.hasStyleNameChanged(nextProps, styleNames)\n        );\n      }\n\n      resolveStyleNames(props) {\n        const { styleName } = props;\n        const styleNames = styleName ? styleName.split(/\\s/g) : [];\n\n        if (!mapPropsToStyleNames) {\n          return styleNames;\n        }\n\n        // We only want to keep the unique style names\n        return _.uniq(mapPropsToStyleNames(styleNames, props));\n      }\n\n      resolveAddedProps() {\n        const addedProps = {};\n        if (options.withRef) {\n          addedProps.ref = \"wrappedInstance\";\n        }\n        return addedProps;\n      }\n\n      getOrSetStylesInCache(context, props, styleNames, path) {\n        if (themeCache && themeCache[path.join(\">\")]) {\n          // console.log('**************');\n\n          return themeCache[path.join(\">\")];\n        } else {\n          resolvedStyle = this.resolveStyle(context, props, styleNames);\n          if (Object.keys(themeCache).length < 10000) {\n            themeCache[path.join(\">\")] = resolvedStyle;\n          }\n          return resolvedStyle;\n        }\n      }\n\n      resolveStyle(context, props, styleNames) {\n        let parentStyle = {};\n\n        const theme = getTheme(context);\n        const themeStyle = theme.createComponentStyle(\n          componentStyleName,\n          componentStyle\n        );\n\n        if (context.parentPath) {\n          parentStyle = themeCache[context.parentPath.join(\">\")];\n        } else {\n          parentStyle = resolveComponentStyle(\n            componentStyleName,\n            styleNames,\n            themeStyle,\n            parentStyle\n          );\n        }\n\n        return resolveComponentStyle(\n          componentStyleName,\n          styleNames,\n          themeStyle,\n          parentStyle\n        );\n      }\n\n      /**\n       * A helper function provided to child components that enables\n       * them to resolve their style for any set of prop values.\n       *\n       * @param props The component props to use to resolve the style values.\n       * @returns {*} The resolved component style.\n       */\n      resolveConnectedComponentStyle(props) {\n        const styleNames = this.resolveStyleNames(props);\n        return this.resolveStyle(this.context, props, styleNames)\n          .componentStyle;\n      }\n\n      render() {\n        // console.log('themeCache', themeCache);\n\n        // if(componentStyleName == 'NativeBase.Text') {\n        //   console.log(this.state.style);\n        //   console.log(themeCache);\n        // }\n\n        const { addedProps, style } = this.state;\n        return (\n          <WrappedComponent\n            {...this.props}\n            {...addedProps}\n            style={style}\n            ref={this.setWrappedInstance}\n          />\n        );\n      }\n    }\n\n    return hoistStatics(StyledComponent, WrappedComponent);\n  };\n};\n"]}]